# Usuario del sistema con el que se ejecutan los procesos de Nginx.
# En la imagen oficial de Nginx suele existir el usuario 'nginx' por defecto.
# No es buena idea ejecutarlo como root salvo que sea estrictamente necesario.
user nginx;

# Número de procesos worker que Nginx va a lanzar.
# - 'auto' hace que Nginx detecte el número de CPUs y cree un worker por CPU.
# - Es la opción recomendada en la mayoría de casos.
worker_processes auto;

events {
    # Bloque 'events': define cómo maneja Nginx las conexiones a bajo nivel.
    # Número máximo de conexiones simultáneas por worker.
    # Con 1024 conexiones por worker y varios workers, soportas miles de conexiones simultáneas.
    worker_connections 1024;
}

# Bloque principal HTTP: aquí configuramos el servidor web / reverse proxy.
http {
    # Incluimos el archivo de tipos MIME que trae Nginx por defecto.
    # Esto permite que Nginx asigne correctamente el 'Content-Type' (text/html, image/png, etc.)
    # según la extensión del archivo.
    include /etc/nginx/mime.types;

    # Tipo por defecto para respuestas cuyo tipo no se detecta.
    # 'application/octet-stream' es un tipo genérico de binario.
    default_type application/octet-stream;

    # ######################################
    # # Configuración de logs
    # # ####################################

    # Archivo de log de acceso donde se guardan las peticiones HTTP recibidas.
    # Formato por defecto: IP, fecha, método, URL, código de estado, etc.
    access_log /var/log/nginx/access.log;

    # Archivo de log de errores.
    # El nivel 'warn' indica que se registran avisos, errores y mensajes más graves.
    error_log /var/log/nginx/error.log warn;

    # #############################
    # # Ajustes generales
    # #############################

    # Habilita el envío eficiente de archivos (usa sendfile() del SO).
    # Mejora rendimiento en la entrega de archivos estáticos.
    sendfile on;

    # Tiempo máximo que se mantiene una conexión keep-alive abierta con el cliente
    # esperando nuevas peticiones antes de cerrarla.
    # 65 segundos es un valor razonable para la mayoría de aplicaciones.
    keepalive_timeout 65;


    # #############################
    # # Definición del backend
    # #############################

    # Bloque 'upstream': define un grupo de servidores backend al que Nginx
    # va a reenviar las peticiones (reverse proxy).
    # En este caso apuntamos a nuestro contenedor de Spring Boot 'ticket-logger-app'
    # escuchando en el puerto 8080 dentro de la red de Docker.
    upstream ticket_logger_backend {
        # Nombre del host: 'ticket-logger-app' es el nombre del servicio en docker-compose.
        # El Docker Swarm crea una red interna donde cada servicio se resuelve por su nombre.
        server ticket-logger-app:8080;
        # Aquí podrías añadir más 'server' para balanceo de carga si tuvieras varias instancias.
    }


    # #############################
    # # Servidor HTTP (puerto 80)
    # #############################
    # Este bloque 'server' escucha en el puerto 80 (HTTP sin cifrar).
    # Lo usamos solo para redirigir todo el tráfico a HTTPS (puerto 443).
    server {
        # Puerto de escucha sin TLS.
        listen 80;

        # Nombre del servidor (host) que este bloque atiende.
        # Para desarrollo usamos 'localhost'; en producción pondrías tu dominio.
        server_name localhost;

        # Redirección permanente (código 301) a la misma URL pero en HTTPS.
        # $host          -> host de la petición original (cabecera Host).
        # $request_uri   -> resto de la ruta + parámetros de la URL original.
        # Resultado: http://localhost/lo-que-sea -> https://localhost/lo-que-sea
        return 301 https://$host$request_uri;
    }
    # ############################
    # # Servidor HTTPS (puerto 443)
    # ############################

    server {
        # Escuchamos en el puerto 443 con SSL/TLS activado.
        listen 443 ssl;

        # Nombre del servidor que atiende este bloque.
        # De nuevo 'localhost' para desarrollo; en producción, tu dominio real.
        server_name localhost;

        # Rutas del certificado y la clave privada que hemos generado
        # (por ejemplo, con el script docker-entrypoint).
        # Deben coincidir con lo que haya en /etc/nginx/certs dentro del contenedor.
        ssl_certificate /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;

        # Versión de protocolos TLS que permitimos.
        # TLSv1.2 y TLSv1.3 son las versiones recomendadas hoy en día.
        # TLSv1.0 y 1.1 están desaconsejados por motivos de seguridad.
        ssl_protocols TLSv1.2 TLSv1.3;

        # Conjunto de cifrados permitidos.
        # HIGH      -> cifrados de alta seguridad.
        # !aNULL    -> descarta cifrados sin autenticación.
        # !MD5      -> descarta cifrados que usan MD5 (obsoleto e inseguro).
        # En producción se suele afinar esta lista siguiendo guías como Mozilla SSL Config.
        ssl_ciphers HIGH:!aNULL:!MD5;
        # Reglas de enrutado
        # #############################

        # Bloque 'location /' -> se aplica a todas las rutas que empiecen por /
        # (es decir, todas las peticiones).
        location / {
            # Reenviamos la petición al backend definido en 'upstream' (Spring Boot).
            # 'http://ticket_logger_backend' se resuelve al grupo de servidores
            # definidos arriba.
            proxy_pass http://ticket_logger_backend;

            # Ajustamos cabeceras para que la aplicación backend reciba
            # información útil sobre el cliente original:
            #
            # Host original que usó el cliente (localhost, dominio, etc.).
            proxy_set_header Host $host;

            # IP real del cliente (la IP desde la que accede el usuario).
            # Útil para logs, auditoría, etc.
            proxy_set_header X-Real-IP $remote_addr;

            # Cadena de IPs por las que ha pasado la petición (proxies intermedios).
            # Es la cabecera estándar para mantener el rastreo de IPs.
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # Protocolo original visto por el cliente.
            # Como Nginx termina TLS, hacia el backend va en HTTP, pero aquí marcamos
            # 'https' para que la aplicación (Spring Boot) sepa que el cliente habló
            # con HTTPS. Esto es importante, por ejemplo, para generar URLs absolutas,
            # redirecciones, links, etc.
            proxy_set_header X-Forwarded-Proto https;
        }
    }
}
